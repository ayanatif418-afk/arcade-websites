<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man - The Webcade</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P:wght@400&display=swap" rel="stylesheet">
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <button id="backBtn" class="back-btn">‚Üê Back to Arcade</button>
            <div class="game-info">
                <span class="score">Score: <span id="scoreValue">0</span></span>
                <span class="score">High: <span id="highScoreValue">0</span></span>
                <span class="lives">Lives: <span id="livesValue">3</span></span>
            </div>
        </div>
        
        <canvas id="gameCanvas" class="game-canvas" width="600" height="660"></canvas>
        
        <div class="controls-info" style="margin-top: 20px; text-align: center; font-size: 10px; color: #cccccc;">
            <p>Arrow keys or WASD to move ‚Ä¢ Mobile: Swipe to change direction</p>
        </div>
    </div>

    <div id="gameOver" class="game-over hidden">
        <h2>Game Over!</h2>
        <p>Score: <span id="finalScore">0</span></p>
        <p id="newHighScore" style="color: #ffff00; display: none;">üéâ New High Score! üéâ</p>
        <button id="restartBtn" class="restart-btn">Play Again</button>
        <button id="homeBtn" class="restart-btn">Back to Arcade</button>
    </div>

    <script src="gameBase.js"></script>
    <script src="main.js"></script>
    <script>
        class PacManGame extends GameBase {
            constructor() {
                super('gameCanvas', 'pacman');
                this.cellSize = 20;
                this.cols = 30;
                this.rows = 33;
                this.canvas.width = this.cols * this.cellSize;
                this.canvas.height = this.rows * this.cellSize;
                this.init();
                this.gameLoop();
            }

            init() {
                this.maze = [
                    "##############################",
                    "#............##............#",
                    "#.####.#####.##.#####.####.#",
                    "#o####.#####.##.#####.####o#",
                    "#..........................#",
                    "#.####.##.########.##.####.#",
                    "#......##....##....##......#",
                    "######.#####.##.#####.######",
                    "     #.#####.##.#####.#     ",
                    "     #.##..........##.#     ",
                    "     #.##.###--###.##.#     ",
                    "######.##.#      #.##.######",
                    "      ....#      #....      ",
                    "######.##.#      #.##.######",
                    "     #.##.########.##.#     ",
                    "     #.##..........##.#     ",
                    "     #.##.########.##.#     ",
                    "######.##.########.##.######",
                    "#............##............#",
                    "#.####.#####.##.#####.####.#",
                    "#o..##................##..o#",
                    "###.##.##.########.##.##.###",
                    "#......##....##....##......#",
                    "#.##########.##.##########.#",
                    "#..........................#",
                    "##############################"
                ];

                this.pacman = {
                    x: 15,
                    y: 20,
                    direction: { x: 0, y: 0 },
                    nextDirection: { x: 0, y: 0 }
                };

                this.ghosts = [
                    { x: 15, y: 12, direction: { x: 1, y: 0 }, color: '#ff0000', mode: 'chase' },
                    { x: 14, y: 12, direction: { x: -1, y: 0 }, color: '#ffb8ff', mode: 'chase' },
                    { x: 16, y: 12, direction: { x: 1, y: 0 }, color: '#00ffff', mode: 'chase' },
                    { x: 15, y: 11, direction: { x: 0, y: -1 }, color: '#ffb852', mode: 'chase' }
                ];

                this.score = 0;
                this.lives = 3;
                this.gameOver = false;
                this.powerPelletTimer = 0;
                this.dotsRemaining = this.countDots();
                
                document.getElementById('highScoreValue').textContent = this.highScore;
                document.getElementById('livesValue').textContent = this.lives;
                
                this.attachEventListeners();
            }

            countDots() {
                let count = 0;
                for (let row = 0; row < this.maze.length; row++) {
                    for (let col = 0; col < this.maze[row].length; col++) {
                        if (this.maze[row][col] === '.' || this.maze[row][col] === 'o') {
                            count++;
                        }
                    }
                }
                return count;
            }

            attachEventListeners() {
                document.addEventListener('keydown', (e) => {
                    if (this.gameOver || this.paused) return;
                    
                    switch(e.code) {
                        case 'ArrowUp':
                        case 'KeyW':
                            this.pacman.nextDirection = { x: 0, y: -1 };
                            break;
                        case 'ArrowDown':
                        case 'KeyS':
                            this.pacman.nextDirection = { x: 0, y: 1 };
                            break;
                        case 'ArrowLeft':
                        case 'KeyA':
                            this.pacman.nextDirection = { x: -1, y: 0 };
                            break;
                        case 'ArrowRight':
                        case 'KeyD':
                            this.pacman.nextDirection = { x: 1, y: 0 };
                            break;
                    }
                });

                // Touch controls
                let startX, startY;
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (!startX || !startY || this.gameOver || this.paused) return;

                    const endX = e.changedTouches[0].clientX;
                    const endY = e.changedTouches[0].clientY;
                    const diffX = startX - endX;
                    const diffY = startY - endY;

                    if (Math.abs(diffX) > Math.abs(diffY)) {
                        if (diffX > 20) {
                            this.pacman.nextDirection = { x: -1, y: 0 };
                        } else if (diffX < -20) {
                            this.pacman.nextDirection = { x: 1, y: 0 };
                        }
                    } else {
                        if (diffY > 20) {
                            this.pacman.nextDirection = { x: 0, y: -1 };
                        } else if (diffY < -20) {
                            this.pacman.nextDirection = { x: 0, y: 1 };
                        }
                    }
                });
            }

            canMove(x, y, direction) {
                const newX = x + direction.x;
                const newY = y + direction.y;
                
                if (newY < 0 || newY >= this.maze.length || newX < 0 || newX >= this.maze[0].length) {
                    return false;
                }
                
                return this.maze[newY][newX] !== '#';
            }

            update() {
                if (this.gameOver || this.paused) return;

                // Update power pellet timer
                if (this.powerPelletTimer > 0) {
                    this.powerPelletTimer--;
                }

                // Try to change direction
                if (this.canMove(this.pacman.x, this.pacman.y, this.pacman.nextDirection)) {
                    this.pacman.direction = { ...this.pacman.nextDirection };
                }

                // Move Pac-Man
                if (this.canMove(this.pacman.x, this.pacman.y, this.pacman.direction)) {
                    this.pacman.x += this.pacman.direction.x;
                    this.pacman.y += this.pacman.direction.y;

                    // Tunnel effect
                    if (this.pacman.x < 0) this.pacman.x = this.cols - 1;
                    if (this.pacman.x >= this.cols) this.pacman.x = 0;

                    // Eat dots
                    const cell = this.maze[this.pacman.y][this.pacman.x];
                    if (cell === '.') {
                        this.maze[this.pacman.y] = this.maze[this.pacman.y].substring(0, this.pacman.x) + ' ' + 
                                                   this.maze[this.pacman.y].substring(this.pacman.x + 1);
                        this.score += 10;
                        this.dotsRemaining--;
                        this.updateScore(this.score);
                        WebcadeUtils.playSound(880, 0.05);
                    } else if (cell === 'o') {
                        this.maze[this.pacman.y] = this.maze[this.pacman.y].substring(0, this.pacman.x) + ' ' + 
                                                   this.maze[this.pacman.y].substring(this.pacman.x + 1);
                        this.score += 50;
                        this.dotsRemaining--;
                        this.powerPelletTimer = 300;
                        this.updateScore(this.score);
                        WebcadeUtils.playSound(440, 0.2);
                    }
                }

                // Move ghosts
                this.ghosts.forEach(ghost => {
                    const directions = [
                        { x: 0, y: -1 },
                        { x: 0, y: 1 },
                        { x: -1, y: 0 },
                        { x: 1, y: 0 }
                    ];

                    const validDirections = directions.filter(dir => 
                        this.canMove(ghost.x, ghost.y, dir) &&
                        !(dir.x === -ghost.direction.x && dir.y === -ghost.direction.y)
                    );

                    if (validDirections.length > 0) {
                        if (this.powerPelletTimer > 0) {
                            // Run away from Pac-Man
                            ghost.direction = validDirections[Math.floor(Math.random() * validDirections.length)];
                        } else {
                            // Simple AI - move towards Pac-Man occasionally
                            if (Math.random() < 0.7) {
                                const dx = this.pacman.x - ghost.x;
                                const dy = this.pacman.y - ghost.y;
                                
                                let bestDirection = validDirections[0];
                                let bestDistance = Infinity;
                                
                                validDirections.forEach(dir => {
                                    const newX = ghost.x + dir.x;
                                    const newY = ghost.y + dir.y;
                                    const distance = Math.abs(newX - this.pacman.x) + Math.abs(newY - this.pacman.y);
                                    
                                    if (distance < bestDistance) {
                                        bestDistance = distance;
                                        bestDirection = dir;
                                    }
                                });
                                
                                ghost.direction = bestDirection;
                            } else {
                                ghost.direction = validDirections[Math.floor(Math.random() * validDirections.length)];
                            }
                        }
                    }

                    if (this.canMove(ghost.x, ghost.y, ghost.direction)) {
                        ghost.x += ghost.direction.x;
                        ghost.y += ghost.direction.y;

                        // Tunnel effect for ghosts
                        if (ghost.x < 0) ghost.x = this.cols - 1;
                        if (ghost.x >= this.cols) ghost.x = 0;
                    }
                });

                // Check collisions with ghosts
                this.ghosts.forEach(ghost => {
                    if (ghost.x === this.pacman.x && ghost.y === this.pacman.y) {
                        if (this.powerPelletTimer > 0) {
                            // Eat ghost
                            this.score += 200;
                            this.updateScore(this.score);
                            ghost.x = 15;
                            ghost.y = 12;
                            WebcadeUtils.playSound(660, 0.3);
                        } else {
                            // Pac-Man dies
                            this.lives--;
                            document.getElementById('livesValue').textContent = this.lives;
                            
                            if (this.lives <= 0) {
                                this.endGame();
                            } else {
                                this.resetPositions();
                            }
                            WebcadeUtils.playSound(220, 0.5);
                        }
                    }
                });

                // Check win condition
                if (this.dotsRemaining === 0) {
                    this.endGame('You Win!');
                }
            }

            resetPositions() {
                this.pacman.x = 15;
                this.pacman.y = 20;
                this.pacman.direction = { x: 0, y: 0 };
                this.pacman.nextDirection = { x: 0, y: 0 };

                this.ghosts[0] = { x: 15, y: 12, direction: { x: 1, y: 0 }, color: '#ff0000', mode: 'chase' };
                this.ghosts[1] = { x: 14, y: 12, direction: { x: -1, y: 0 }, color: '#ffb8ff', mode: 'chase' };
                this.ghosts[2] = { x: 16, y: 12, direction: { x: 1, y: 0 }, color: '#00ffff', mode: 'chase' };
                this.ghosts[3] = { x: 15, y: 11, direction: { x: 0, y: -1 }, color: '#ffb852', mode: 'chase' };
            }

            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw maze
                for (let row = 0; row < this.maze.length; row++) {
                    for (let col = 0; col < this.maze[row].length; col++) {
                        const cell = this.maze[row][col];
                        const x = col * this.cellSize;
                        const y = row * this.cellSize;

                        if (cell === '#') {
                            this.ctx.fillStyle = '#0000ff';
                            this.ctx.fillRect(x, y, this.cellSize, this.cellSize);
                        } else if (cell === '.') {
                            this.ctx.fillStyle = '#ffff00';
                            this.ctx.fillRect(x + this.cellSize / 2 - 2, y + this.cellSize / 2 - 2, 4, 4);
                        } else if (cell === 'o') {
                            this.ctx.fillStyle = '#ffff00';
                            this.ctx.fillRect(x + this.cellSize / 2 - 4, y + this.cellSize / 2 - 4, 8, 8);
                        }
                    }
                }

                // Draw Pac-Man
                this.ctx.fillStyle = '#ffff00';
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = '#ffff00';
                this.ctx.fillRect(
                    this.pacman.x * this.cellSize + 2,
                    this.pacman.y * this.cellSize + 2,
                    this.cellSize - 4,
                    this.cellSize - 4
                );

                // Draw ghosts
                this.ghosts.forEach(ghost => {
                    if (this.powerPelletTimer > 0 && this.powerPelletTimer < 100 && Math.floor(this.powerPelletTimer / 10) % 2) {
                        this.ctx.fillStyle = '#ffffff';
                    } else if (this.powerPelletTimer > 0) {
                        this.ctx.fillStyle = '#0000ff';
                    } else {
                        this.ctx.fillStyle = ghost.color;
                    }
                    
                    this.ctx.shadowColor = this.ctx.fillStyle;
                    this.ctx.fillRect(
                        ghost.x * this.cellSize + 2,
                        ghost.y * this.cellSize + 2,
                        this.cellSize - 4,
                        this.cellSize - 4
                    );
                });

                this.ctx.shadowBlur = 0;

                if (this.paused) {
                    this.drawPauseScreen();
                }
            }

            endGame(message = 'Game Over!') {
                this.gameOver = true;
                document.getElementById('gameOverTitle').textContent = message;
                this.showGameOver();
            }

            restart() {
                this.init();
            }

            gameLoop() {
                this.update();
                this.draw();
                setTimeout(() => this.gameLoop(), 150);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new PacManGame();
        });
    </script>
</body>
</html>