<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 - The Webcade</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P:wght@400&display=swap" rel="stylesheet">
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <button id="backBtn" class="back-btn">‚Üê Back to Arcade</button>
            <div class="game-info">
                <span class="score">Score: <span id="scoreValue">0</span></span>
                <span class="score">High: <span id="highScoreValue">0</span></span>
            </div>
        </div>
        
        <canvas id="gameCanvas" class="game-canvas" width="480" height="480"></canvas>
        
        <div class="controls-info" style="margin-top: 20px; text-align: center; font-size: 10px; color: #cccccc;">
            <p>Arrow keys or WASD to move tiles ‚Ä¢ Mobile: Swipe to move</p>
            <p>Combine tiles to reach 2048!</p>
        </div>
    </div>

    <div id="gameOver" class="game-over hidden">
        <h2 id="gameOverTitle">Game Over!</h2>
        <p>Score: <span id="finalScore">0</span></p>
        <p id="newHighScore" style="color: #ffff00; display: none;">üéâ New High Score! üéâ</p>
        <button id="restartBtn" class="restart-btn">Play Again</button>
        <button id="homeBtn" class="restart-btn">Back to Arcade</button>
    </div>

    <script src="gameBase.js"></script>
    <script src="main.js"></script>
    <script>
        class Game2048 extends GameBase {
            constructor() {
                super('gameCanvas', '2048');
                this.gridSize = 4;
                this.cellSize = 110;
                this.cellPadding = 10;
                this.canvas.width = this.gridSize * this.cellSize + (this.gridSize + 1) * this.cellPadding;
                this.canvas.height = this.canvas.width;
                this.init();
                this.gameLoop();
            }

            init() {
                this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
                this.score = 0;
                this.gameOver = false;
                this.won = false;
                
                this.addRandomTile();
                this.addRandomTile();
                
                document.getElementById('highScoreValue').textContent = this.highScore;
                
                this.attachEventListeners();
            }

            addRandomTile() {
                const emptyCells = [];
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.grid[row][col] === 0) {
                            emptyCells.push({ row, col });
                        }
                    }
                }

                if (emptyCells.length > 0) {
                    const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    this.grid[randomCell.row][randomCell.col] = Math.random() < 0.9 ? 2 : 4;
                }
            }

            attachEventListeners() {
                document.addEventListener('keydown', (e) => {
                    if (this.gameOver || this.paused) return;
                    
                    let moved = false;
                    switch(e.code) {
                        case 'ArrowUp':
                        case 'KeyW':
                            moved = this.move('up');
                            break;
                        case 'ArrowDown':
                        case 'KeyS':
                            moved = this.move('down');
                            break;
                        case 'ArrowLeft':
                        case 'KeyA':
                            moved = this.move('left');
                            break;
                        case 'ArrowRight':
                        case 'KeyD':
                            moved = this.move('right');
                            break;
                    }

                    if (moved) {
                        this.addRandomTile();
                        this.checkGameState();
                        WebcadeUtils.playSound(440, 0.1);
                    }
                });

                // Touch controls
                let startX, startY;
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (!startX || !startY || this.gameOver || this.paused) return;

                    const endX = e.changedTouches[0].clientX;
                    const endY = e.changedTouches[0].clientY;
                    const diffX = startX - endX;
                    const diffY = startY - endY;

                    let moved = false;
                    if (Math.abs(diffX) > Math.abs(diffY)) {
                        if (Math.abs(diffX) > 30) {
                            if (diffX > 0) {
                                moved = this.move('left');
                            } else {
                                moved = this.move('right');
                            }
                        }
                    } else {
                        if (Math.abs(diffY) > 30) {
                            if (diffY > 0) {
                                moved = this.move('up');
                            } else {
                                moved = this.move('down');
                            }
                        }
                    }

                    if (moved) {
                        this.addRandomTile();
                        this.checkGameState();
                        WebcadeUtils.playSound(440, 0.1);
                    }
                });
            }

            move(direction) {
                const previousGrid = this.grid.map(row => [...row]);
                let moved = false;

                if (direction === 'left') {
                    for (let row = 0; row < this.gridSize; row++) {
                        const newRow = this.slideAndMerge(this.grid[row]);
                        this.grid[row] = newRow;
                    }
                } else if (direction === 'right') {
                    for (let row = 0; row < this.gridSize; row++) {
                        const reversed = [...this.grid[row]].reverse();
                        const newRow = this.slideAndMerge(reversed).reverse();
                        this.grid[row] = newRow;
                    }
                } else if (direction === 'up') {
                    for (let col = 0; col < this.gridSize; col++) {
                        const column = [];
                        for (let row = 0; row < this.gridSize; row++) {
                            column.push(this.grid[row][col]);
                        }
                        const newColumn = this.slideAndMerge(column);
                        for (let row = 0; row < this.gridSize; row++) {
                            this.grid[row][col] = newColumn[row];
                        }
                    }
                } else if (direction === 'down') {
                    for (let col = 0; col < this.gridSize; col++) {
                        const column = [];
                        for (let row = 0; row < this.gridSize; row++) {
                            column.push(this.grid[row][col]);
                        }
                        const reversed = [...column].reverse();
                        const newColumn = this.slideAndMerge(reversed).reverse();
                        for (let row = 0; row < this.gridSize; row++) {
                            this.grid[row][col] = newColumn[row];
                        }
                    }
                }

                // Check if grid changed
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.grid[row][col] !== previousGrid[row][col]) {
                            moved = true;
                            break;
                        }
                    }
                    if (moved) break;
                }

                return moved;
            }

            slideAndMerge(row) {
                // Remove zeros
                let newRow = row.filter(val => val !== 0);
                
                // Merge adjacent equal values
                for (let i = 0; i < newRow.length - 1; i++) {
                    if (newRow[i] === newRow[i + 1]) {
                        newRow[i] *= 2;
                        this.score += newRow[i];
                        this.updateScore(this.score);
                        newRow[i + 1] = 0;
                        
                        if (newRow[i] === 2048 && !this.won) {
                            this.won = true;
                            setTimeout(() => {
                                alert('Congratulations! You reached 2048!');
                            }, 100);
                        }
                    }
                }
                
                // Remove zeros again
                newRow = newRow.filter(val => val !== 0);
                
                // Pad with zeros
                while (newRow.length < this.gridSize) {
                    newRow.push(0);
                }
                
                return newRow;
            }

            checkGameState() {
                // Check for empty cells
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.grid[row][col] === 0) {
                            return; // Game can continue
                        }
                    }
                }

                // Check for possible merges
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const current = this.grid[row][col];
                        
                        // Check right
                        if (col < this.gridSize - 1 && this.grid[row][col + 1] === current) {
                            return; // Game can continue
                        }
                        
                        // Check down
                        if (row < this.gridSize - 1 && this.grid[row + 1][col] === current) {
                            return; // Game can continue
                        }
                    }
                }

                // No moves possible
                this.endGame();
            }

            getTileColor(value) {
                const colors = {
                    2: '#eee4da',
                    4: '#ede0c8',
                    8: '#f2b179',
                    16: '#f59563',
                    32: '#f67c5f',
                    64: '#f65e3b',
                    128: '#edcf72',
                    256: '#edcc61',
                    512: '#edc850',
                    1024: '#edc53f',
                    2048: '#edc22e'
                };
                return colors[value] || '#3c3a32';
            }

            getTileTextColor(value) {
                return value <= 4 ? '#776e65' : '#f9f6f2';
            }

            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#bbada0';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw grid
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const x = col * this.cellSize + (col + 1) * this.cellPadding;
                        const y = row * this.cellSize + (row + 1) * this.cellPadding;
                        const value = this.grid[row][col];

                        // Draw cell background
                        this.ctx.fillStyle = value === 0 ? '#cdc1b4' : this.getTileColor(value);
                        this.ctx.fillRect(x, y, this.cellSize, this.cellSize);

                        // Draw value
                        if (value !== 0) {
                            this.ctx.fillStyle = this.getTileTextColor(value);
                            this.ctx.font = value < 100 ? '32px "Press Start 2P"' : 
                                           value < 1000 ? '24px "Press Start 2P"' : '20px "Press Start 2P"';
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.fillText(
                                value.toString(),
                                x + this.cellSize / 2,
                                y + this.cellSize / 2
                            );
                        }
                    }
                }

                if (this.paused) {
                    this.drawPauseScreen();
                }
            }

            endGame() {
                this.gameOver = true;
                this.showGameOver();
            }

            restart() {
                this.init();
            }

            gameLoop() {
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new Game2048();
        });
    </script>
</body>
</html>